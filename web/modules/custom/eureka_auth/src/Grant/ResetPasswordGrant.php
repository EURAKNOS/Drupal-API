<?php

namespace Drupal\eureka_auth\Grant;

use Drupal\eureka_auth\Repositories\UserRepositoryInterface;
use League\OAuth2\Server\Entities\ClientEntityInterface;
use League\OAuth2\Server\Entities\UserEntityInterface;
use League\OAuth2\Server\Exception\OAuthServerException;
use League\OAuth2\Server\Grant\AbstractGrant;
use League\OAuth2\Server\Repositories\RefreshTokenRepositoryInterface;
use League\OAuth2\Server\RequestEvent;
use League\OAuth2\Server\ResponseTypes\ResponseTypeInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * With some auth requests we don't know the password.
 * E.g. one time login's for password resets or registration confirmation mails.
 * These URL's are generated with a timestamp and a hashed code.
 * This grant type works with a timestamp and a token generated by these URLs.
 */
class ResetPasswordGrant extends AbstractGrant {

  /**
   * The user repository.
   *
   * @var \Drupal\eureka_auth\Repositories\UserRepositoryInterface $userRepository
   */
  protected $userRepository;

  /**
   * @param UserRepositoryInterface $userRepository
   * @param RefreshTokenRepositoryInterface $refreshTokenRepository
   */
  public function __construct(UserRepositoryInterface $userRepository, RefreshTokenRepositoryInterface $refreshTokenRepository) {
    $this->userRepository =  $userRepository;
    $this->setRefreshTokenRepository($refreshTokenRepository);

    $this->refreshTokenTTL = new \DateInterval('P1M');
  }

    /**
     * {@inheritdoc}
     */
    public function respondToAccessTokenRequest(ServerRequestInterface $request, ResponseTypeInterface $responseType, \DateInterval $accessTokenTTL) {
      // Validate request
      $client = $this->validateClient($request);
      $scopes = $this->validateScopes($this->getRequestParameter('scope', $request, $this->defaultScope));
      $user = $this->validateUser($request, $client);

      // Finalize the requested scopes
      $finalizedScopes = $this->scopeRepository->finalizeScopes($scopes, $this->getIdentifier(), $client, $user->getIdentifier());

      // Issue and persist new tokens
      $accessToken = $this->issueAccessToken($accessTokenTTL, $client, $user->getIdentifier(), $finalizedScopes);
      $refreshToken = $this->issueRefreshToken($accessToken);

      // Inject tokens into response
      $responseType->setAccessToken($accessToken);
      $responseType->setRefreshToken($refreshToken);

      return $responseType;
    }

    /**
     * @param ServerRequestInterface $request
     * @param ClientEntityInterface  $client
     *
     * @throws OAuthServerException
     *
     * @return UserEntityInterface
     */
    protected function validateUser(ServerRequestInterface $request, ClientEntityInterface $client){
      $username = $this->getRequestParameter('username', $request);
      $hash = $this->getRequestParameter('hash', $request);
      $timestamp = $this->getRequestParameter('timestamp', $request);

      if (is_null($username)) {
        throw OAuthServerException::invalidRequest('username');
      }

      if (is_null($hash)) {
        throw OAuthServerException::invalidRequest('hash');
      }

      if (is_null($timestamp)) {
        throw OAuthServerException::invalidRequest('timestamp');
      }

      $user = $this->userRepository->getUserEntityByHash(
        $hash,
        $username,
        $timestamp,
        $this->getIdentifier(),
        $client
      );

      if ($user instanceof UserEntityInterface === false) {
        $this->getEmitter()->emit(new RequestEvent(RequestEvent::USER_AUTHENTICATION_FAILED, $request));

        throw OAuthServerException::invalidCredentials();
      }

      return $user;
    }

    /**
     * {@inheritdoc}
     */
    public function getIdentifier() {
      return 'reset_password';
    }
  }
